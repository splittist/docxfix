"""CLI application for docxfix using Typer."""

from pathlib import Path
from typing import Annotated

import typer
import yaml

from docxfix.generator import DocumentGenerator
from docxfix.input_parser import SpecParseError, parse_spec_file
from docxfix.spec import DocumentSpec
from docxfix.validator import ValidationError, validate_docx

app = typer.Typer(
    name="docxfix",
    help=(
        "A CLI utility for creating docx fixtures with "
        "desirable characteristics for testing."
    ),
)


@app.command()
def create(
    output: Annotated[
        str,
        typer.Argument(help="Output path for the generated docx fixture"),
    ],
    spec: Annotated[
        str | None,
        typer.Option(
            "--spec",
            "-s",
            help="Spec file (JSON/YAML) to use for document generation",
        ),
    ] = None,
    template: Annotated[
        str | None,
        typer.Option(
            "--template",
            "-t",
            help="Template docx file to use as base",
        ),
    ] = None,
    validate: Annotated[
        bool,
        typer.Option(
            "--validate/--no-validate",
            help="Validate the generated document",
        ),
    ] = True,
    verbose: Annotated[
        bool,
        typer.Option(
            "--verbose",
            "-v",
            help="Enable verbose output",
        ),
    ] = False,
) -> None:
    """Create a new docx fixture."""
    if verbose:
        typer.echo(f"Creating docx fixture at: {output}")
        if template:
            typer.echo(f"Using template: {template}")
        if spec:
            typer.echo(f"Using spec file: {spec}")

    try:
        # Load spec from file or create default
        if spec:
            if verbose:
                typer.echo(f"Parsing spec file: {spec}")
            doc_spec = parse_spec_file(spec)
        else:
            # Create a simple document spec (basic example)
            doc_spec = DocumentSpec(
                title="Test Document",
                author="Test User",
            )
            doc_spec.add_paragraph("This is a test document generated by docxfix.")

        # Generate the document
        generator = DocumentGenerator(doc_spec)
        generator.generate(output)

        if verbose:
            typer.echo("Document generated")

        # Validate if requested
        if validate:
            if verbose:
                typer.echo("Validating document...")
            validate_docx(output)
            if verbose:
                typer.echo("Validation passed")

        typer.echo("✓ Docx fixture created successfully!")

    except SpecParseError as e:
        typer.echo(f"✗ Spec parsing error: {e}", err=True)
        raise typer.Exit(code=1) from e
    except ValidationError as e:
        typer.echo(f"✗ Validation error: {e}", err=True)
        raise typer.Exit(code=1) from e
    except FileNotFoundError as e:
        typer.echo(f"✗ File not found: {e}", err=True)
        raise typer.Exit(code=1) from e
    except Exception as e:
        typer.echo(f"✗ Error creating fixture: {e}", err=True)
        raise typer.Exit(code=1) from e


@app.command()
def batch(
    manifest: Annotated[
        str,
        typer.Option(
            "--manifest",
            "-m",
            help="Batch manifest file (YAML) listing fixtures to generate",
        ),
    ],
    out_dir: Annotated[
        str,
        typer.Option(
            "--out-dir",
            "-o",
            help="Output directory for generated fixtures",
        ),
    ] = "fixtures",
    validate: Annotated[
        bool,
        typer.Option(
            "--validate/--no-validate",
            help="Validate the generated documents",
        ),
    ] = True,
    verbose: Annotated[
        bool,
        typer.Option(
            "--verbose",
            "-v",
            help="Enable verbose output",
        ),
    ] = False,
) -> None:
    """Generate multiple fixtures from a batch manifest file.

    Manifest format (YAML):
        fixtures:
          - id: simple-doc
            spec: path/to/spec.yaml
            output: simple.docx
          - id: complex-doc
            spec: path/to/another.yaml
            output: complex.docx
    """
    if verbose:
        typer.echo(f"Loading batch manifest: {manifest}")
        typer.echo(f"Output directory: {out_dir}")

    try:
        # Load manifest
        manifest_path = Path(manifest)
        if not manifest_path.exists():
            raise FileNotFoundError(f"Manifest file not found: {manifest}")

        with open(manifest_path) as f:
            manifest_data = yaml.safe_load(f)

        if not isinstance(manifest_data, dict) or "fixtures" not in manifest_data:
            raise ValueError(
                "Manifest must contain 'fixtures' key with list of fixtures"
            )

        fixtures = manifest_data["fixtures"]
        if not isinstance(fixtures, list):
            raise ValueError("'fixtures' must be a list")

        # Create output directory
        out_path = Path(out_dir)
        out_path.mkdir(parents=True, exist_ok=True)

        # Track results
        success_count = 0
        failed_fixtures = []

        # Process each fixture
        for i, fixture_def in enumerate(fixtures, 1):
            if not isinstance(fixture_def, dict):
                typer.echo(
                    f"✗ Fixture {i}: Invalid fixture definition (not a dict)",
                    err=True,
                )
                failed_fixtures.append((i, "Invalid fixture definition"))
                continue

            fixture_id = fixture_def.get("id", f"fixture-{i}")
            spec_path = fixture_def.get("spec")
            output_name = fixture_def.get("output")

            if not spec_path:
                typer.echo(f"✗ Fixture '{fixture_id}': Missing 'spec' field", err=True)
                failed_fixtures.append((fixture_id, "Missing 'spec' field"))
                continue

            if not output_name:
                typer.echo(
                    f"✗ Fixture '{fixture_id}': Missing 'output' field", err=True
                )
                failed_fixtures.append((fixture_id, "Missing 'output' field"))
                continue

            # Resolve spec path relative to manifest directory
            spec_file = manifest_path.parent / spec_path
            output_file = out_path / output_name

            if verbose:
                typer.echo(f"\n[{i}/{len(fixtures)}] Processing '{fixture_id}'...")
                typer.echo(f"  Spec: {spec_file}")
                typer.echo(f"  Output: {output_file}")

            try:
                # Parse spec and generate
                doc_spec = parse_spec_file(str(spec_file))
                generator = DocumentGenerator(doc_spec)
                generator.generate(str(output_file))

                # Validate if requested
                if validate:
                    validate_docx(str(output_file))

                if verbose:
                    typer.echo("  ✓ Generated successfully")
                else:
                    typer.echo(f"✓ {fixture_id}")

                success_count += 1

            except SpecParseError as e:
                typer.echo(
                    f"✗ Fixture '{fixture_id}': Spec parsing error: {e}", err=True
                )
                failed_fixtures.append((fixture_id, f"Spec error: {str(e)[:100]}"))
            except ValidationError as e:
                typer.echo(
                    f"✗ Fixture '{fixture_id}': Validation error: {e}", err=True
                )
                failed_fixtures.append(
                    (fixture_id, f"Validation error: {str(e)[:100]}")
                )
            except FileNotFoundError as e:
                typer.echo(f"✗ Fixture '{fixture_id}': File not found: {e}", err=True)
                failed_fixtures.append((fixture_id, f"File not found: {e}"))
            except Exception as e:
                typer.echo(f"✗ Fixture '{fixture_id}': Error: {e}", err=True)
                failed_fixtures.append((fixture_id, f"Error: {str(e)[:100]}"))

        # Summary
        typer.echo(f"\n{'='*60}")
        typer.echo("Batch generation complete:")
        typer.echo(f"  Total: {len(fixtures)}")
        typer.echo(f"  Success: {success_count}")
        typer.echo(f"  Failed: {len(failed_fixtures)}")

        if failed_fixtures:
            typer.echo("\nFailed fixtures:")
            for fixture_id, error in failed_fixtures:
                typer.echo(f"  - {fixture_id}: {error}")
            raise typer.Exit(code=1)

    except (FileNotFoundError, ValueError) as e:
        typer.echo(f"✗ Manifest error: {e}", err=True)
        raise typer.Exit(code=1) from e
    except Exception as e:
        typer.echo(f"✗ Unexpected error: {e}", err=True)
        raise typer.Exit(code=1) from e


@app.command()
def info() -> None:
    """Display information about docxfix."""
    from docxfix import __version__

    typer.echo(f"docxfix version {__version__}")
    typer.echo(
        "A CLI utility for creating docx fixtures with "
        "desirable characteristics for testing."
    )


def main() -> None:
    """Entry point for the CLI application."""
    app()


if __name__ == "__main__":
    main()
